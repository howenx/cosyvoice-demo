import os
import sys
import torch
import numpy as np
import soundfile as sf
import uuid
import logging

# 获取当前文件所在的目录 (CosyVoice/demo/back/core/)
current_dir = os.path.dirname(os.path.abspath(__file__))

# CosyVoice 仓库的根目录 (CosyVoice/)
cosyvoice_repo_root = os.path.abspath(os.path.join(current_dir, '..', '..', '..'))

# 将 CosyVoice 仓库根目录添加到 sys.path，以便找到 cosyvoice 包
sys.path.insert(0, cosyvoice_repo_root)
# 将 third_party/Matcha-TTS 目录添加到 sys.path，这是 cosyvoice 的内部依赖
sys.path.insert(0, os.path.join(cosyvoice_repo_root, 'third_party', 'Matcha-TTS'))

# 尝试导入 CosyVoice 库
try:
    from cosyvoice.cli.cosyvoice import CosyVoice2
    from cosyvoice.utils.file_utils import load_wav
    import torchaudio # 确保 torchaudio 也被导入
    logging.info("CosyVoice library imported successfully.")
except ImportError as e:
    logging.error(f"Error importing CosyVoice2: {e}")
    logging.error("Please ensure CosyVoice2 library is correctly installed or its path is added to sys.path.")
    logging.error(f"Current sys.path: {sys.path}")
    logging.error(f"Expected cosyvoice package in: {os.path.join(cosyvoice_repo_root, 'cosyvoice')}")
    logging.error(f"Expected third_party/Matcha-TTS in: {os.path.join(cosyvoice_repo_root, 'third_party', 'Matcha-TTS')}")
    sys.exit(1)

class CosyVoiceManager:
    _instance = None
    _model = None
    _sampling_rate = 24000 # Default, will be updated after model load

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(CosyVoiceManager, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance

    def __init__(self):
        if self._initialized:
            return
        
        self.MODEL_LOCAL_PATH = os.path.join(cosyvoice_repo_root, "pretrained_models", "CosyVoice2-0.5B")
        self.DEFAULT_PROMPT_WAV = os.path.join(cosyvoice_repo_root, "asset", "zero_24000.wav")
        self.DEFAULT_PROMPT_TEXT = "希望你以后能够做的比我还好呦。"
        
        # Output directory for generated audio (relative to back/ directory)
        self.OUTPUT_DIR = os.path.abspath(os.path.join(current_dir, '..', "generated_audio"))
        os.makedirs(self.OUTPUT_DIR, exist_ok=True)
        
        self._initialized = True

    async def load_model(self):
        if CosyVoiceManager._model is None:
            logging.info(f"Loading CosyVoice 2-0.5B model from {self.MODEL_LOCAL_PATH}...")
            
            if not os.path.exists(self.MODEL_LOCAL_PATH):
                raise RuntimeError(f"Model path not found: {self.MODEL_LOCAL_PATH}. Please ensure it's downloaded.")
            
            # CosyVoice2 内部会检查 CUDA 可用性并决定设备
            if torch.cuda.is_available():
                logging.info(f"CUDA is available. Using device: {torch.cuda.get_device_name(0)}")
            else:
                logging.info("CUDA is not available. Using CPU.")

            CosyVoiceManager._model = CosyVoice2(
                self.MODEL_LOCAL_PATH, 
                load_jit=False, 
                load_trt=False, 
                fp16=False 
            )
            CosyVoiceManager._sampling_rate = CosyVoiceManager._model.sample_rate
            logging.info(f"CosyVoice 2-0.5B model loaded successfully. Sampling rate: {self._sampling_rate} Hz")

    def get_model(self):
        if CosyVoiceManager._model is None:
            raise RuntimeError("CosyVoice model is not loaded. Call load_model() first.")
        return CosyVoiceManager._model

    def get_sampling_rate(self):
        return CosyVoiceManager._sampling_rate

    def get_output_dir(self):
        return self.OUTPUT_DIR

    async def generate_audio(self, text: str) -> str:
        model = self.get_model()
        sampling_rate = self.get_sampling_rate()

        if not os.path.exists(self.DEFAULT_PROMPT_WAV):
            raise FileNotFoundError(f"Default prompt WAV file '{self.DEFAULT_PROMPT_WAV}' not found on server. Please ensure it exists.")
        
        prompt_speech_np = load_wav(self.DEFAULT_PROMPT_WAV, sampling_rate)
        generated_audios = self._model.inference_zero_shot( # <--- 将 self.model 改为 self._model
            text,
            self.DEFAULT_PROMPT_TEXT,
            prompt_speech_np,
            stream=False
        )

        audio_tensor = None
        for i, j in enumerate(generated_audios):
            audio_tensor = j['tts_speech']
            break 
        
        if audio_tensor is None:
            raise ValueError("No audio generated by the model.")

        file_uuid = uuid.uuid4()
        filename = f"tts_audio_{file_uuid}.wav"
        filepath = os.path.join(self.OUTPUT_DIR, filename)

        # !!! 关键修复点：直接使用 torchaudio.save，与官方示例一致 !!!
        # torchaudio.save 期望的采样率是模型实际输出的采样率
        torchaudio.save(filepath, audio_tensor.cpu(), CosyVoiceManager._model.sample_rate)
        logging.info(f"Generated audio saved to: {filepath} with sampling rate: {CosyVoiceManager._model.sample_rate} Hz")

        return filename

# 单例模式，确保只有一个模型实例
cosyvoice_manager = CosyVoiceManager()

